import { CONFIG } from '../config'
import { showError, showSuccess } from '../utils/notificationUtils'
import { Connection, LAMPORTS_PER_SOL, PublicKey } from '@solana/web3.js'

export interface DepositRequest {
  linkId: string
  amount: string
  publicKey: string
}

/**
 * ‚úÖ HYBRID FLOW - Backend generates proof, User signs and pays
 * 
 * CORRECT ARCHITECTURE:
 * 1. Frontend: Check user balance
 * 2. Frontend: Request backend to generate ZK proof + unsigned transaction
 * 3. Backend: Init Privacy Cash SDK with operator keypair (needed for SDK)
 * 4. Backend: Generate ZK proof for user's address
 * 5. Backend: Create UNSIGNED transaction
 * 6. Backend: Return transaction to frontend
 * 7. Frontend: User signs transaction with Phantom (user's private key)
 * 8. Frontend: Send SIGNED transaction to backend
 * 9. Backend: Relay signed transaction to blockchain (USER PAYS FEES)
 * 10. Backend: Record transaction
 * 
 * Key Points:
 * - Operator keypair only used for SDK init & proof generation
 * - Operator does NOT sign the transaction
 * - User signs the transaction (their private key, their fees)
 * - User pays all transaction fees
 * - Operator wallet balance not used
 */
export async function executeUserPaysDeposit(
  request: DepositRequest,
  wallet: any
): Promise<string> {
  const { linkId, amount, publicKey } = request
  const lamports = Math.round(parseFloat(amount) * 1e9)

  console.log('üí∞ Processing payment (USER PAYS)...')
  console.log(`   üìã Step 1: Backend generates Privacy Cash proof`)
  console.log(`   üîê Step 2: You sign transaction`)
  console.log(`   üì§ Step 3: Backend relays (you pay fees)`)

  try {
    // ‚úÖ STEP 1: Check balance first
    console.log('\nüîç Step 1: Checking your wallet balance...')
    console.log(`   Amount needed: ${amount} SOL + ~0.002 SOL fees`)
    
    const rpcUrl = process.env.VITE_SOLANA_RPC_URL || CONFIG.SOLANA_RPC_URL || 
      'https://mainnet.helius-rpc.com/?api-key=c455719c-354b-4a44-98d4-27f8a18aa79c'
    
    const connection = new Connection(rpcUrl)
    const balance = await connection.getBalance(wallet.publicKey)
    const balanceSOL = balance / LAMPORTS_PER_SOL
    
    console.log(`   Your balance: ${balanceSOL.toFixed(6)} SOL`)
    
    const estimatedFees = 2_000_000 // ~0.002 SOL
    const totalNeeded = lamports + estimatedFees
    const totalNeededSOL = totalNeeded / LAMPORTS_PER_SOL
    
    if (balance < totalNeeded) {
      const shortfall = (totalNeeded - balance) / LAMPORTS_PER_SOL
      throw new Error(
        `Insufficient balance. You have ${balanceSOL.toFixed(6)} SOL, ` +
        `but need ${totalNeededSOL.toFixed(6)} SOL ` +
        `(${parseFloat(amount).toFixed(6)} SOL deposit + 0.002 SOL fees). ` +
        `Please add ${shortfall.toFixed(6)} SOL to your wallet.`
      )
    }
    
    console.log(`   ‚úÖ Balance sufficient\n`)

    // ‚úÖ STEP 2: Request backend to generate ZK proof + unsigned transaction
    console.log(`üîê Step 2: Requesting backend to generate Privacy Cash proof...`)
    console.log(`   Backend will:`)
    console.log(`   - Initialize Privacy Cash SDK`)
    console.log(`   - Generate ZK proof for your address`)
    console.log(`   - Create unsigned transaction`)
    
    const preparePayload = {
      linkId,
      amount: amount.toString(),
      publicKey,
      lamports,
    }

    const prepareResponse = await fetch(
      `${CONFIG.BACKEND_URL}/api/deposit/prepare`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(preparePayload),
      }
    )

    if (!prepareResponse.ok) {
      const errorData = await prepareResponse.json().catch(() => ({}))
      throw new Error(
        errorData.details || 
        `Backend error: ${prepareResponse.status}`
      )
    }

    const prepareData = await prepareResponse.json()
    if (!prepareData.transaction) {
      throw new Error('Backend did not return unsigned transaction')
    }

    console.log(`   ‚úÖ ZK proof generated by backend`)
    console.log(`   ‚úÖ Unsigned transaction created\n`)

    // ‚úÖ STEP 3: Deserialize transaction and user signs it
    console.log(`‚úçÔ∏è  Step 3: Signing transaction with your wallet...`)
    console.log(`   Phantom will ask you to approve`)
    
    // Import necessary web3 classes
    const { Transaction } = await import('@solana/web3.js')
    
    // Decode base64 transaction
    const transactionBuffer = Buffer.from(prepareData.transaction, 'base64')
    const transaction = Transaction.from(transactionBuffer)
    
    // User signs with Phantom (their private key)
    console.log(`   Waiting for your signature in Phantom...`)
    let signedTransaction: any
    try {
      signedTransaction = await wallet.signTransaction(transaction)
    } catch (signErr: any) {
      if (signErr.message?.includes('rejected')) {
        throw new Error('You rejected the transaction. Please try again and click "Approve" in Phantom.')
      }
      throw signErr
    }

    // Serialize signed transaction back to base64
    const signedTxBase64 = signedTransaction.serialize().toString('base64')
    
    console.log(`   ‚úÖ Transaction signed by your wallet`)
    console.log(`   ‚úÖ Your signature: ${signedTxBase64.substring(0, 40)}...\n`)

    // ‚úÖ STEP 4: Send signed transaction to backend for relay
    console.log(`üì§ Step 4: Relaying signed transaction to blockchain...`)
    console.log(`   Backend will submit your signed transaction`)
    console.log(`   Your wallet will pay all transaction fees`)
    
    const relayPayload = {
      linkId,
      amount: amount.toString(),
      publicKey,
      lamports,
      signedTransaction: signedTxBase64,
    }

    const relayResponse = await fetch(
      `${CONFIG.BACKEND_URL}/api/deposit`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(relayPayload),
      }
    )

    if (!relayResponse.ok) {
      const errorData = await relayResponse.json().catch(() => ({}))
      throw new Error(
        errorData.details || 
        `Relay error: ${relayResponse.status}`
      )
    }

    const relayData = await relayResponse.json()
    const transactionSignature = relayData.transactionHash || relayData.tx
    
    if (!transactionSignature) {
      throw new Error('Backend did not return transaction signature')
    }

    console.log(`   ‚úÖ Transaction submitted to blockchain`)
    console.log(`   ‚úÖ Transaction signature: ${transactionSignature}\n`)

    // ‚úÖ STEP 5: Wait for confirmation
    console.log(`‚è≥ Step 5: Waiting for blockchain confirmation...`)
    
    try {
      const confirmation = await connection.confirmTransaction(transactionSignature, 'confirmed')
      
      if (confirmation.value.err) {
        throw new Error('Transaction failed on blockchain')
      }
      
      console.log(`   ‚úÖ Transaction confirmed on blockchain`)
    } catch (confirmErr) {
      console.log(`   ‚ö†Ô∏è  Could not confirm (might still be processing)`)
    }

    // ‚úÖ SUCCESS
    console.log(`\n‚úÖ DEPOSIT SUCCESSFUL!`)
    console.log(`   Amount: ${amount} SOL`)
    console.log(`   Status: Confirmed on blockchain`)
    console.log(`   Privacy: Zero-knowledge encrypted`)
    console.log(`   You paid: ~${(lamports / LAMPORTS_PER_SOL).toFixed(6)} SOL + transaction fees`)
    console.log(`   Transaction: ${transactionSignature}`)
    console.log(`   Explorer: https://solscan.io/tx/${transactionSignature}`)

    showSuccess(
      `‚úÖ Deposit Successful!\n` +
      `Amount: ${amount} SOL\n` +
      `Status: Confirmed on blockchain\n` +
      `Privacy: Zero-knowledge encrypted\n` +
      `You paid all fees\n` +
      `Tx: ${transactionSignature.slice(0, 20)}...\n\n` +
      `View on Explorer: https://solscan.io/tx/${transactionSignature}`
    )

    return transactionSignature

  } catch (error: any) {
    console.error('‚ùå Deposit flow error:', error.message)
    console.error('‚ùå Full error:', error)

    let errorMsg = error.message || 'Unknown error'
    
    // User-friendly error messages
    if (error.message?.toLowerCase().includes('user rejected') || 
        error.message?.includes('rejected')) {
      errorMsg = 'You rejected the transaction. Please try again and approve in Phantom.'
    } else if (error.message?.toLowerCase().includes('insufficient')) {
      errorMsg = error.message
    } else if (error.message?.includes('network') || error.message?.includes('connection')) {
      errorMsg = 'Network error. Please check your internet connection and try again.'
    } else if (error.message?.includes('timeout')) {
      errorMsg = 'Request timed out. Please try again.'
    } else if (error.message?.includes('simulation failed')) {
      errorMsg = 'Transaction simulation failed. Please try again.'
    } else if (error.message?.includes('Backend proof generation failed')) {
      errorMsg = 'Backend could not generate Privacy Cash proof. This might be a temporary issue. Please try again.'
    }

    showError(`‚ùå Deposit failed: ${errorMsg}`)
    throw new Error(errorMsg)
  }
}

/**
 * Helper: Format lamports to SOL
 */
function formatSOL(lamports: number): string {
  return (lamports / LAMPORTS_PER_SOL).toFixed(6)
}

// Keep old function for backward compatibility
export const executeRealDeposit = executeUserPaysDeposit
